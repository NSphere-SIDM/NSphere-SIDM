<div align="left">
  <img src="img/NSphere.png" alt="NSphere logo" width="60%">
</div>

[![docs](https://github.com/kris-sigurdson/NSphere/actions/workflows/docs-status.yml/badge.svg)](https://kris-sigurdson.github.io/NSphere/)
[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](LICENSE)
[![arXiv](https://img.shields.io/badge/arXiv-2504.13996-b31b1b.svg)](https://arxiv.org/abs/2504.13996)

Please see **Kamionkowski & Sigurdson (2025), arXiv:2504.13996** if you use **NSphere** (citation details below).

---

## Quick Navigation
- [Overview](#overview)
- [Numerical Implementation](#numerical-implementation)
- [Core Components & Usage](#core-components--usage)
- [Installation](#installation)
- [Running NSphere](#running-nsphere)
- [Examples](#examples)
- [Data and Results Flow](#data-and-results-flow)
- [Citation](#citation)
- [Dependencies and Acknowledgments](#dependencies-and-acknowledgments)
- [Building Documentation](#building-documentation-optional)

---

## Overview

NSphere simulates the evolution of spherical self-gravitating systems, primarily targeting collisionless dark matter halos in astrophysics. It leverages the inherent spherical symmetry to simplify the complex ùëÅ-body problem. By reducing the six-dimensional phase space (position and velocity) to three dimensions (radius `r`, radial velocity `ùë£·µ£`, and angular momentum `‚Ñì` or velocity angle), the computational cost is significantly lowered. The core principle is self-consistency: the gravitational potential is generated by the mass distribution of all particles, and particles orbit within that potential. In equilibrium, such systems, described by a phase-space Distribution Function (DF) often dependent on energy (`Œµ`) and angular momentum (`‚Ñì`), are generally stable. NSphere provides a tool to efficiently explore how these systems evolve when perturbed or subjected to new physical processes (e.g., dark matter interactions, central black hole growth, external tidal forces) where analytical solutions are intractable.

<table style="width:100%; border-collapse:collapse;">
  <tr>
    <td align="center" style="width:50%;">
      <img src="img/Phase_Space_Animation_Stable_100000_5.gif" alt="Stable Animation" style="max-width:90%; height:auto;"><br>
      <em>Stable self-gravitating distribution with 10‚Åµ particles</em>
    </td>
    <td align="center" style="width:50%;">
      <img src="img/Phase_Space_Animation_Tidal_12000000_25.gif" alt="Tidal Animation" style="max-width:90%; height:auto;"><br>
      <em>Tidally stripped system with 1.2 x 10‚Å∑ particles</em>
    </td>
  </tr>
</table>

## Numerical Implementation

The simulation evolves a system of ùëÅ particles, often representing concentric mass shells. The algorithm proceeds in discrete time steps. At each step:
1.  **Sorting:** Particles are efficiently sorted by their radial coordinate `r`. This allows for rapid calculation of the mass enclosed within any radius, `M(r)`, which determines the gravitational force. The implementation utilizes optimized sorting algorithms like Quadsort, achieving nearly `ùëÅ log ùëÅ` or even linear scaling for the nearly-ordered data typical between steps.
2.  **Force Calculation:** The gravitational force on each particle is calculated based solely on the mass `M(r)` enclosed within its current radius (Newton's Shell Theorem). Centrifugal force due to angular momentum (`‚Ñì¬≤/r¬≥`) is added.
3.  **Integration:** Particle states (radius `r` and radial velocity `ùë£·µ£`) are updated using a numerical integrator. NSphere employs adaptive leapfrog methods, automatically refining the time step for accuracy. For orbits with very low angular momentum approaching the center (`r` -> 0), where standard integration becomes stiff, a Levi-Civita coordinate transformation (`œ± = ‚àö(r)`) and fictitious time (`dœÑ = dt/r`) are used to regularize the equations of motion and improved stability and accuracy.

This approach significantly reduces computational cost compared to traditional `ùëÅ¬≤` ùëÅ-body methods and mitigates issues like two-body relaxation effects, making it suitable for high-precision studies of spherical systems on standard hardware.

*(For more technical details, see the full [Online Documentation](https://kris-sigurdson.github.io/NSphere/))* <!-- Replace <hosted_docs_url> -->

## Core Components & Usage

The primary components intended for user interaction reside in the project root directory:

*   `./nsphere`: The compiled C executable. This is the core simulation engine that reads parameters and initial conditions, runs the N-body evolution according to the chosen physics and numerical method, and outputs simulation data (snapshots, profiles) to the `data/` directory.
    *   See the [C API Documentation](https://kris-sigurdson.github.io/NSphere/c_api/index.html) for details (primarily for developers). <!-- Replace <hosted_docs_url> -->
*   `./nsphere_plot`: The main Python executable script for visualization and analysis. It reads output files from the `data/` directory and generates various plots (density profiles, mass profiles, energy conservation checks, trajectories, phase space diagrams) and animations, saving them to the `results/` directory.
    *   See the [Python API Documentation](https://kris-sigurdson.github.io/NSphere/python_api/index.html) for details on its functions (for users and developers wanting to use the plotting library). <!-- Replace <hosted_docs_url> -->

**Command-Line Help:** Both `./nsphere` and `./nsphere_plot` support the `--help` flag to display available command-line options and usage instructions.

**Convenience Wrappers:** Several wrapper scripts are provided for common plotting tasks:
*   `./nsphere_animations`: Generates standard profile and phase-space animations.
*   `./nsphere_distributions`: Creates histograms comparing initial and final 1D distributions (radius, velocity, etc.).
*   `./nsphere_2d_histograms`: Generates initial and final 2D phase-space histograms.
*   See the [Command-Line Usage Guide](https://kris-sigurdson.github.io/NSphere/usage/command_line.html) for details on these wrappers. <!-- Replace <hosted_docs_url> -->

## Installation

Follow these steps to obtain the code, install dependencies, and compile NSphere.

**1. Clone the Repository:**
   First, clone the NSphere repository from GitHub using HTTPS:
   ```bash
   git clone https://github.com/kris-sigurdson/NSphere.git
   ```
   Then, navigate into the newly created project directory:
   ```bash
   cd NSphere
   ```
   All subsequent commands should be run from within this `NSphere` directory.

**2. Install System Dependencies:**
   NSphere requires several system dependencies: core C libraries (GSL, FFTW3, OpenMP), Python 3 (with pip and venv), and standard build tools (Make, our suggested C compiler Clang). An automated script is provided to attempt installation on common systems.
   *   **Run the install script (Linux, macOS, Windows/MSYS2):**
       Navigate to the cloned `NSphere` directory in your terminal and run:
       ```bash
       bash install_nsphere.sh
       ```
       This will attempt to use your system's package manager (`apt`, `dnf`, `pacman`, `brew`) to install the full set of required system dependencies (C libraries, Python tools, build tools). The script is optimized for each platform and installs platform-specific Python packages when appropriate and necessary.
       *   **Windows Users:** This script requires the [MSYS2](https://www.msys2.org/) environment. Run the script from the **MSYS2 CLANG64** shell. Note: Windows Subsystem for Linux (WSL2) users should follow the Linux instructions.
   *   **Manual Installation (If script fails or for other systems):**
       See the detailed manual installation commands for specific platforms below.

**3. Compile NSphere:**
   Once C libraries are installed, compile the code using Make:
   ```bash
   make all
   ```
   This will create the `./nsphere` executable and the Python wrapper executables (e.g., `./nsphere_plot`) in the project root.

**4. Setup & Activate Python Environment:**
   NSphere's plotting and analysis tools require Python 3.8+ and several packages within a dedicated virtual environment.

   Run the activation script using `source`:
   From the project root directory, you must use `source` (or `.`) to run the script so it can activate the environment in your current shell:
   ```bash
   source ./activate_nsphere
   # or alternatively:
   # . ./activate_nsphere
   ```
   *First time:* This environment-aware script creates the `./venv/nsphere` environment (optimized for your platform), installs required Python packages from `requirements.txt`, and activates the environment.
   *Subsequent times:* The script verifies all required packages are installed, offers to fix any missing dependencies, and activates the environment for your current shell.

   *Verify Activation:* Your shell prompt should change to include `(nsphere)`. If it didn't change, ensure you used `source` or `.` to run the script.

**Manual System Dependency Installation Details (Alternative to using install_nsphere.sh):**

These commands install the C libraries, Python tools, and build tools.

*   **Debian/Ubuntu:** `sudo apt update && sudo apt install libgsl-dev libfftw3-dev libomp-dev python3 python3-pip python3-venv make clang`
*   **Fedora:** `sudo dnf update && sudo dnf install gsl-devel fftw-devel libomp-devel python3 python3-pip make clang`
*   **Arch Linux:** `sudo pacman -Syu && sudo pacman -S gsl fftw openmp python python-pip make clang`
*   **macOS ([Homebrew](https://brew.sh/)):** `brew update && brew install gsl fftw python`. Additionally, ensure the Apple Command Line Tools are installed (provides `make` and `clang`) by running: `xcode-select --install` (follow the on-screen prompts).
*   **Windows ([MSYS2](https://www.msys2.org/) CLANG64):** Requires MSYS2. Run in CLANG64 shell: `pacman -S mingw-w64-clang-x86_64-gsl mingw-w64-clang-x86_64-fftw mingw-w64-clang-x86_64-openmp mingw-w64-clang-x86_64-python mingw-w64-clang-x86_64-python-pip mingw-w64-clang-x86_64-make mingw-w64-clang-x86_64-clang mingw-w64-clang-x86_64-python-matplotlib mingw-w64-clang-x86_64-python-scipy mingw-w64-clang-x86_64-python-jupyterlab mingw-w64-clang-x86_64-python-psutil`. These MSYS2-optimized Python packages are installed at the system level to avoid unnecessary compilation.
*   **Windows ([MSVC](https://visualstudio.microsoft.com/vs/features/cplusplus/)):** Requires Microsoft Visual C++ with the C++ workload and OpenMP component.
    1. **Install Dependencies Using vcpkg:**
       ```powershell
       # Install vcpkg if you don't have it already
       git clone https://github.com/microsoft/vcpkg.git C:\dev\vcpkg
       cd C:\dev\vcpkg
       .\bootstrap-vcpkg.bat
       
       # Install required libraries
       .\vcpkg install gsl:x64-windows fftw3:x64-windows
       
       # Optionally integrate with Visual Studio
       .\vcpkg integrate install
       ```
    
    2. **Build NSphere:**
       - Open a "Developer Command Prompt for VS" (available from Start menu after installing Visual Studio)
       - Navigate to your NSphere directory:
         ```
         cd path\to\NSphere
         ```
       - Build using nmake:
         ```
         nmake /f Makefile.Windows USE_MSVC=1
         ```
       
    3. **Clean Build Files:**
       ```
       nmake /f Makefile.Windows clean USE_MSVC=1
       ```

**Manual Python Environment Setup (Alternative to using activate_nsphere):**

For Linux and macOS:
```bash
python3 -m venv venv/nsphere
source venv/nsphere/bin/activate # For bash/zsh shells
python -m pip install --upgrade pip
python -m pip install -r requirements.txt
```

For Windows with MSVC:
```powershell
# In Developer Command Prompt for VS or regular PowerShell
python -m venv venv\nsphere
venv\nsphere\Scripts\Activate.ps1   # For PowerShell
# OR
# venv\nsphere\Scripts\activate   # For Command Prompt
python -m pip install --upgrade pip
python -m pip install -r requirements.txt
```

For MSYS2/CLANG64 specifically, use the `--system-site-packages` flag to access the system packages:
```bash
python -m venv venv/nsphere --system-site-packages
source venv/nsphere/bin/activate # (or equivalent for your shell)
python -m pip install --upgrade pip
python -m pip install -r requirements.txt
```

Alternatively, these dependencies could be installed directly into a global or other existing Python environment using `pip install -r requirements.txt` (not recommended), but be aware this may cause version conflicts with other installed packages.

## Running NSphere

**Activate Environment:** You must activate the Python virtual environment before running any NSphere Python scripts or wrappers. If your session isn't already active (prompt doesn't show `(nsphere)`), run:
```bash
source ./activate_nsphere
```

**Run Simulation:** Execute the C simulation engine from the project root:
```bash
./nsphere [options...]
```
(Use `./nsphere --help` for options)

**Run Plotting/Analysis:** Execute the Python scripts from the project root:
```bash
./nsphere_plot [options...]
# or use wrappers:
# ./nsphere_animations [options...]
# ./nsphere_distributions [options...]
# ./nsphere_2d_histograms [options...]
```
(Use `--help` for options)

**Deactivate Environment:** When finished, you can deactivate the environment:
```bash
deactivate
```

## Examples

A Jupyter Notebook example demonstrating how to load and visualize simulation output is available:

*   **`examples/nsphere_notebook_example1.ipynb`**: Shows how to create phase-space and density profile animations from the `.dat` files generated by `./nsphere`. This provides a starting point for custom analysis and visualization using Python and demonstrates how to read NSphere binary data formats. See the notebook itself for prerequisites and usage instructions.

You can explore this notebook using Jupyter Lab or Jupyter Notebook after activating the Python environment (`source ./activate_nsphere` from the project root) and navigating to the `examples/` directory.

## Data and Results Flow

The NSphere workflow typically involves simulation followed by analysis:

1.  **Simulation (`./nsphere`):** The C executable, `./nsphere`, handles the core physics simulation. It takes command-line arguments or reads configuration to set up parameters like particle count, simulation time, and physics models. It may read initial particle configurations from the `init/` directory (if present and configured). During execution, it calculates particle trajectories under self-gravity and any additional physics, outputting results primarily to the `data/` directory (created in the current working directory if it doesn't exist). This output includes time-series data, particle snapshots at specified intervals (`Rank_Mass_Rad_VRad*.dat`), and potentially theoretically calculated profiles (`massprofile*.dat`, etc.). A `lastparams*.dat` file is often written to record key parameters of the run.

2.  **Visualization/Analysis (`./nsphere_plot` and wrappers):** The Python executable, `./nsphere_plot`, along with its convenience wrappers, processes the files generated by the simulation, expecting them in the `data/` directory relative to the current working directory. It typically uses a `--suffix` argument to identify the specific simulation run's data files. Based on command-line flags, these scripts read the relevant data, perform analysis, and use the Matplotlib library to generate various outputs (plots as `.png` files, animations as `.gif` files) which are saved to the `results/` directory (also created in the current working directory if needed).

## Citation

For Methods, Science, and Algorithms please cite:

**Paper Citation:**

*   Kamionkowski, M. & Sigurdson, K. (2025).
    "Evolution of self-gravitating spherical dark-matter halos with and without new physics.",
    arXiv preprint arXiv:2504.13996 [astro-ph.GA]. \
    [https://arxiv.org/abs/2504.13996](https://arxiv.org/abs/2504.13996)

*BibTeX for Paper:*
````bibtex
@article{KamionkowskiSigurdson2025,
  author       = {Kamionkowski, Marc and Sigurdson, Kris},
  title        = {Evolution of self-gravitating spherical dark-matter halos with and without new physics},
  journal      = {arXiv e-prints},
  year         = {2025},
  eprint       = {2504.13996},
  archivePrefix= {arXiv},
  primaryClass = {astro-ph.GA},
  url          = {https://arxiv.org/abs/2504.13996}
}
````

---
If you wish to reference a specific software version please cite:

**Software Citation (v0.1.2):**

*   Sigurdson, K., & Kamionkowski, M. (2025). *NSphere: Spherical N-body Simulation Code* (Version 0.1.2) [Software]. GitHub. https://github.com/kris-sigurdson/NSphere

*BibTeX for Software:*
````bibtex
@software{SigurdsonKamionkowski2025NSphereSoftware,
  author       = {Sigurdson, Kris and Kamionkowski, Marc},
  title        = {{NSphere: Spherical N-body Simulation Code}},
  version      = {0.1.2},
  year         = {2025},
  publisher    = {GitHub},
  url          = {https://github.com/kris-sigurdson/NSphere}
}
````

*(The "Cite this repository" button on the GitHub sidebar primarily provides the paper citation details via `CITATION.cff`.)*

## Dependencies and Acknowledgments

* **Core C Libraries:**  
  [GNU Scientific Library (GSL)](https://www.gnu.org/software/gsl/), [FFTW (Fastest Fourier Transform in the West)](https://www.fftw.org/), [OpenMP](https://www.openmp.org/)

* **Python Packages:**  
  See the `requirements.txt` file for the list of required Python packages and their specific pinned versions; these have been tested for compatibility with this release.

* **Quadsort (Sorting Algorithm):**  
  NSphere utilizes an optimized implementation based on [Quadsort](https://github.com/scandum/quadsort).  
  This project includes code from Quadsort, which is released into the public domain under **The Unlicense**. For a complete copy of Quadsort's license, please refer to:  
  `licenses/third_party/Quadsort/LICENSE`

## Building Documentation (Optional)

Developers can build the documentation locally. This requires installing `Doxygen` and `Pandoc` via your system package manager, and `Sphinx` along with specific Python packages for its extensions and themes via pip.

1.  **Install Doxygen and Pandoc:** Use your system's package manager. Examples:
    *   Debian/Ubuntu: `sudo apt install doxygen pandoc`
    *   Fedora: `sudo dnf install doxygen pandoc`
    *   Arch Linux: `sudo pacman -S doxygen pandoc`
    *   macOS (Homebrew): `brew install doxygen pandoc`
    *   Windows (MSYS2):
        ```bash
        # Install Doxygen and Rust
        pacman -S mingw-w64-clang-x86_64-doxygen mingw-w64-clang-x86_64-rust
        
        # Install Pandoc: download MSI from https://pandoc.org/installing.html, then add to PATH
        echo 'export PATH=$PATH:/c/Program\ Files/Pandoc/' >> ~/.bashrc 
        source ~/.bashrc
        ```

2.  **Generate Doxygen XML:** Navigate to the docs directory and create the XML output needed by Breathe for the C API:
    ```bash
    cd docs/source
    doxygen Doxyfile
    ```

3.  **Activate Environment & Install Dependencies:** Ensure the project's Python virtual environment is active:
    ```bash
    source ./activate_nsphere
    ```
    
    Then install documentation-specific Python packages:
    
    Linux/macOS:
    ```bash
    python -m pip install -r docs/source/requirements-docs.txt
    ```
    
    Windows (to avoid dependency conflicts):
    ```bash
    python -m pip install --no-cache-dir --ignore-installed -r docs/source/requirements-docs.txt
    ```

4.  **Build Sphinx HTML:** From the same source directory, build the HTML documentation:
    ```bash
    make html
    ```

The generated HTML documentation will be located in the `docs/` directory (e.g., `docs/index.html`).
